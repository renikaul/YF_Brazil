---
title: "Manuscript Figures"
author: ""
date: "January 23, 2018"
output: html_document
---

# Packages and Set-Up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)



#fig 3
library(sf)
library(raster)
library(ggplot2)

#fig 4
library(sf)
library(raster)
library(viridis)
library(cowplot)
library(ggthemes)
library(lubridate)
library(dplyr)
library(ggplot2)
```

This document creates the figures for:

*Insert manuscript citation here*

I'm currently loading data individually for each figure, then if you want to remake one figure you don't have to rerun the whole document, just that section.

#Figure 1: Relative Variable Importance as quantiles

The median, and 95% quantile reported for dAUC scaled to max dAUC for each model. 

```{r relative variable importance Quantile}
#function to calculate dAUC stats
RelativeImportance=function(x, model="NA"){
  perms <- x[[3]][complete.cases(x[[3]]),-c(1, dim(x[[3]])[2])] # pull out AUC values, but drop full model and all permuted data columns 
  model.AUC <- as.numeric(as.character(x[[2]][1,2])) # pull out AUC for full model
  # calculate delta AUC
  delta.AUC <- model.AUC- perms
  # scale delta AUC between zero and one
  scale.delta.AUC <- delta.AUC/max(delta.AUC)
  #calculate median, upper and lower quantiles
  Quant.dAUC <- scale.delta.AUC %>% 
    melt(value.name="dAUC") %>% 
    rename(Rep=Var1, Variable=Var2)%>% 
    group_by(Variable) %>%
    summarise(dAUCmean=mean(dAUC),dAUCmedian=median(dAUC),Q975=quantile(dAUC, probs=0.975),Q025=quantile(dAUC, probs=0.025) ) %>%
    arrange(desc(dAUCmedian)) %>%
    mutate(Rank=c(11:1)) %>%
    mutate(Model=model) %>%
    ungroup()
  
  return(Quant.dAUC)
}

#variable names for publication
niceNames <- c("popLog10"="Population",
               "spRich" = "NHP Richness",
               "RFsqrt" = "Mean Rainfall",
               "tempMean" = "Mean Temperature",
               "NDVIScale" = "Scaled NDVI",
               "tempScale" = "Scaled Mean Temperature",
               "primProp" = "NHP Agriculture Overlap",
               "RFScale" = "Scaled Mean Rainfall",
               "fireDenScale" = "Scaled Fire Density",
               "NDVI" ="NDVI",
               "fireDenSqrt" ="Fire Density")

#load data
fullM <- readRDS("../data_out/MS_results/OneModel/Perm100FullModel500TryCatch.rds") 
lowM <- readRDS("../data_out/MS_results/LowModel/lPerm100Model500TryCatch.rds")
highM <- readRDS('../data_out/MS_results/HighModel/HPerm100Model500TryCatch.rds')

#calculate dAUC stats
hri <- RelativeImportance(highM, "High")
lri <- RelativeImportance(lowM, "Low")
fri <- RelativeImportance(fullM, "Single")
allRelImportance<- rbind(fri,lri,hri)

#reorder factors for plotting 
allRelImportance <- within(allRelImportance, Variable <- factor(Variable, levels = c( "popLog10","spRich","RFsqrt","tempMean","NDVIScale","tempScale","primProp","RFScale","fireDenSqrt","NDVI","fireDenScale")))
allRelImportance <- within(allRelImportance, Model <- factor(Model, levels = c("Single","Low","High")))

  
b2 <-   ggplot(allRelImportance, aes(x=Variable, y=dAUCmedian, ymin = Q025, ymax = Q975, fill=Model))+
    geom_crossbar(position="dodge")+
    scale_y_continuous(limits=c(-.05,1))+
    #geom_point(y=allRelImportance$dAUCmean)+
    geom_hline(yintercept = 0.0, color="grey50", linetype=2) +
    ylab("Relative Importance") + xlab("variable") +
    scale_x_discrete("",labels=niceNames) +
    theme_few()+
    theme(axis.text.x=element_text(angle=35, hjust=1), legend.position = c(.8,.8) ) +
    scale_fill_tableau("colorblind10")
  
  tiff("figures/manuscript/VarImpQuantiles.tiff")
  plot(b2)
  dev.off()
  
 # ggplot(allRelImportance, aes(x=Variable, y=dAUCmedian, ymin = Q025, ymax = Q975, fill=Model))+
 #    geom_crossbar()+
 #    facet_grid(Model~.)+
 #    scale_y_continuous(limits=c(-.05,1))+
 #    #geom_point(y=allRelImportance$dAUCmean)+
 #    geom_hline(yintercept = 0.0, color="grey50", linetype=2) +
 #    ylab("Relative Importance") + xlab("variable") +
 #    scale_x_discrete("",labels=niceNames) +
 #    theme_few()+
 #    theme(axis.text.x=element_text(angle=35, hjust=1), legend.position = c(.9,.9) ) +
 #    scale_fill_tableau("colorblind10")
 #  
 #  tiff("figures/manuscript/VarImpQuantilesLattice.tiff")
 #  plot(b2)
 #  dev.off()

```

# Figure 1: Variable Importance (OLD)

Dodged barplot of variable importance, calculated by random pairing of permutations and where error assumes a normal distribution. 

```{r, eval=FALSE}
#1. functions 

#Return Variable importance with stdev
VarImp =function(x){
  matrix.Of.AUCs <- x[[3]]
  var.Imp.AUCs <- matrix.Of.AUCs[complete.cases(matrix.Of.AUCs),-dim(matrix.Of.AUCs)[2]] #drop the all permutated, and rows with NAs (TryCatch failed)
  delta.AUC <- apply(var.Imp.AUCs,1,function(x) {(x[1]-x)/max(x[1]-x)} ) #calculate delta AUC and rescale to max delta AUC 
  #rel.import <- delta.auc/max(delta.auc, na.rm = TRUE) # normalized relative change in AUC from base model only for single variable permutation
  mean.Delta.AUC <- apply(delta.AUC, 1, mean) #mean
  sem.Delta.AUC <- apply(delta.AUC,1,function(x) {sd(x)/sqrt(length(x))}) #standard error of the mean
  summary.Delta.AUC <- as.data.frame(cbind(mean.Delta.AUC, sem.Delta.AUC))#put them together
  summary.Delta.AUC$lci95.Delta.AUC <- apply(summary.Delta.AUC, 1, function(x) x[1]-2*x[2]) #lower 95% CI
  summary.Delta.AUC$uci95.Delta.AUC <- apply(summary.Delta.AUC, 1, function(x) x[1]+2*x[2]) #upper 95% CI
  summary.Delta.AUC$Variable <- rownames(summary.Delta.AUC)
  return(summary.Delta.AUC)
}

#2. Load data
fullM <- readRDS("../data_out/MS_results/OneModel/Perm100FullModel500TryCatch.rds") 
lowM <- readRDS("../data_out/MS_results/LowModel/lPerm100Model500TryCatch.rds")
highM <- readRDS('../data_out/MS_results/HighModel/HPerm100Model500TryCatch.rds')


Full <- VarImp(fullM)
HFull <- VarImp(highM)
LFull <- VarImp(lowM)

RankFull <- rbind(Full[-1,],LFull[-1,], HFull[-1,])
RankFull$Model <- factor(c(rep("Single Point Process", dim(Full)[1]-1),
                           rep("LRR", dim(LFull)[1]-1),
                           rep("HRR", dim(HFull)[1]-1)),
                         levels=c("Single Point Process", "LRR", "HRR"))
#order the variable levels
RankFull <- within(RankFull,
                   Variable <- factor(Variable, 
                                      levels = c("popLog10", "spRich","RFsqrt","tempMean","NDVIScale", "tempScale","primProp",
                                                  "RFScale","fireDenSqrt","NDVI", "fireDenScale")))

#RankFull$varImp <- as.numeric(as.character(RankFull$varImp))
#variable names
niceNames <- c("popLog10"="Population",
               "spRich" = "NHP Richness",
               "RFsqrt" = "Mean Rainfall",
               "tempMean" = "Mean Temperature",
               "NDVIScale" = "Scaled NDVI",
               "tempScale" = "Scaled Mean Temperature",
               "primProp" = "NHP Agriculture Overlap",
               "RFScale" = "Scaled Mean Rainfall",
               "fireDenScale" = "Scaled Fire Density",
               "NDVI" ="NDVI",
               "fireDenSqrt" ="Fire Density")

#Relative Imp Plots

b <-   ggplot(RankFull, aes(x=Variable, y=mean.Delta.AUC,ymin=mean.Delta.AUC-sem.Delta.AUC, ymax=mean.Delta.AUC+sem.Delta.AUC, fill=Model)) + 
  geom_bar(stat="identity",position="dodge")+
  geom_errorbar(position="dodge", colour="black")+
  ylab("Relative Importance") + xlab("variable") +
   #scale_y_continuous(expand = c(0, 0)) +
   scale_x_discrete("",labels=niceNames) +
  theme_few()+
  theme(axis.text.x=element_text(angle=35, hjust=1), legend.position = c(.8,.8) ) +
  scale_fill_tableau("colorblind10")

pdf("figures/manuscript/VarImp.pdf")
plot(b)
dev.off()

#latice alternative
#b2 <- 
  ggplot(RankFull, aes(x=Variable, y=mean.Delta.AUC, fill=Model)) + 
  geom_bar(stat="identity")+
  facet_grid(Model~.)+
  geom_errorbar(aes(ymin=mean.Delta.AUC-2*sem.Delta.AUC, ymax=mean.Delta.AUC+2*sem.Delta.AUC), width=.2, colour="black")+
  ylab("Relative Importance") + xlab("variable") +
   #scale_y_continuous(expand = c(0, 0)) +
   scale_x_discrete("",labels=niceNames) +
  theme_few()+
  theme(axis.text.x=element_text(angle=35, hjust=1), legend.position = c(.8,.8) ) +
  scale_fill_tableau("colorblind10")
  
  pdf("figures/manuscript/VarImpLattice.pdf")
plot(b2)
dev.off()
```


# Figure 2: Coord Plot of Variable Importance Rank Median

Ordered based on medians calculated in figure 1. Must run figure 1 for data prep.  


```{r mean coord plot data prep, eval=FALSE}

# Dodged Variable Importance ----

#1. load packages and functions

#Return Rank Importance
RankImp=function(x){
  #pull out Relative Importance
  RI <- x[[1]]
  #convert varImp to numeric (coming out as factor for some reason)
  RI$varImp <- as.numeric(as.character(RI$varImp))
  #order and add rank
  RI <- RI %>%
    dplyr::arrange(desc(varImp)) %>%
    dplyr::mutate(varRank=dim(RI)[1]:1)
  
  return(RI)
}


#2. Load data
fullM <- readRDS("../data_out/MS_results/OneModel/Perm100FullModel500TryCatch.rds") 
lowM <- readRDS("../data_out/MS_results/LowModel/lPerm100Model500TryCatch.rds")
highM <- readRDS('../data_out/MS_results/HighModel/HPerm100Model500TryCatch.rds')

#3. Pull out variable importance from permutations
Full <- RankImp(fullM)
HFull <- RankImp(highM)
LFull <- RankImp(lowM)

RankFull <- rbind(Full,LFull, HFull)
RankFull$Model <- factor(c(rep("Single Point Process", dim(Full)[1]),
                           rep("LRR", dim(LFull)[1]),
                           rep("HRR", dim(HFull)[1])),
                         levels=c("Single Point Process", "LRR", "HRR"))
```

```{r Coord Plot}
# pull out columns of interest
allRank<- allRelImportance %>% select(Model,Variable,Rank )
#flip order variable 
allRank <- within(allRank,
                   Variable <- factor(Variable, 
                                      levels = c( "fireDenScale","NDVI", "fireDenSqrt","RFScale","primProp", "tempScale","NDVIScale","tempMean", "RFsqrt","spRich", "popLog10" )))


justNamesStart <- c("Population",
               "NHP Richness",
               "Mean Rainfall",
               "Mean Temperature",
                "Scaled NDVI",
               "Scaled Mean\nTemperature",
               "NHP Agriculture\nOverlap",
               "Scaled Mean\nRainfall",
                "Fire\nDensity",
               "NDVI",
               "Scaled Fire Density") 

justNamesEnd <- c(
               "NHP Richness",
               "Population",
               "Mean Temperature",
               "NHP Agriculture\nOverlap",
               "Scaled NDVI",
               "Mean Rainfall",
               "Scaled Mean\nTemperature",
               "Fire\nDensity",
               "NDVI",
               "Scaled Mean\nRainfall",
               "Scaled Fire Density") 

y_levels <- levels(allRelImportance$Variable)

p <- ggplot(allRelImportance, aes(x = Model, y = Rank, group = Variable)) +   # group = id is important!
  geom_hline(yintercept = c(1:11), color="grey80", linetype=2) +
  geom_path(aes(color = Variable),lineend = 'round', linejoin = 'round', size=2) +
  scale_y_discrete(limits = levels(allRelImportance$Variable), labels=c(11:1)) + #ylim/lab details
  ylab("Variable Importance Rank (median) ") +
  xlab("Model")+
  theme_few() +
  scale_x_discrete(expand = c(0, 1)) +
  annotate("text", x = c(0.5), y=c(11:1), label = justNamesStart) + 
  annotate("text", x = c(3.5), y=c(11:1), label = justNamesEnd) + 

    theme(legend.position = "none") 

#tiff("figures/manuscript/Rank.tiff")
pdf("figures/manuscript/RankMedian.pdf")
plot(p)
dev.off()
```

#Figure 3: Maps of Calendar Months

Choose maps at certain time points averaged over calendar months to represent spatial patterns. Don't know which time points as of yet. This will pair with the supplementary gif.

This map will consist of a 3 x 2 lattice, showing three characteristic time points (or mean over multiple months?) across the one and two-part model. The two-part model has each prediction rescaled to teh maximum of each respective model (i.e. low and high NHP). They are then plotted together, with a line denoting the spatial split between the models.

## Load Data

```{r}
braz.map <- st_read("../data_clean", "BRAZpolygons")
braz.map <- rename(braz.map, muni.no = muni_no)

# NHP split index
nhp.split <- readRDS("../data_clean/environmental/twoModelSplit.rds")
nhp.split.map <- left_join(braz.map, nhp.split, by = "muni.no") %>%
  group_by(above5split) %>%
  summarize() %>%
  st_buffer(0.01)

#get brazil outline
# braz.outline <- getData('GADM', country ='BRA', level = 0)
# braz.outline <- st_as_sf(braz.outline)
# braz.outline <- braz.outline %>%
#   mutate(model = "one.model") %>%
#   mutate(above5split = "none") %>%
#   dplyr::select(model, above5split)

#combine nhp split and brazil outline
# split.map <- rbind(nhp.split.map, braz.outline)


# prediction data
pred.one.model <- readRDS("../data_out/MS_results/OneModel/wholePredictions.rds")
pred.highNHP <- readRDS("../data_out/MS_results/HighModel/wholePredictions.rds")
pred.lowNHP <- readRDS("../data_out/MS_results/LowModel/wholePredictions.rds")
```

## Calculate Data for Plots

Rescale low and high NHP data and combine into one dataframe.

```{r}
pred.lowNHP <- pred.lowNHP %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  mutate(model = "two.model")

pred.highNHP <- pred.highNHP %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  mutate(model = "two.model")

pred.one.model <- pred.one.model %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  mutate(model = "one.model")

pred.all <- rbind(pred.lowNHP, pred.highNHP, pred.one.model) %>%
  # get mean by calender month and muni
  mutate(cal.month = month.no %% 12)

pred.all$cal.month[pred.all$cal.month==0] <- 12

pred.all.month <- pred.all %>%
  group_by(muni.no, model, cal.month) %>%
  summarise(mean.pred = mean(pred.scale))

pred.map <- left_join(pred.all.month, braz.map, by = "muni.no")
  
```


## Plot

```{r static map theme}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "right",
    panel.grid = element_blank(),
    plot.background = element_rect(fill = NA, color = NA), 
    panel.background = element_rect(fill = NA, color = NA), 
    legend.background = element_rect(fill = NA, color = NA),
    strip.background = element_blank(),
    strip.text = element_blank(),
    ...
  )
}
```

Subset out months we want (Feb, June, Dec.)

```{r plot all months, eval = F}
for (k in unique(pred.map$model)){
  
  for(i in 1:12){
    
    pdf(file = paste0("figures/Fig4/", gsub("\\.", "", k), "Month", i, ".pdf"), width = 12, height = 12, family = "sans")

    p <- ggplot(data = pred.map[pred.map$cal.month == i & pred.map$model == k,])+
      geom_sf(aes(fill = mean.pred), color = NA) +
      ggtitle(paste(k, "month", i, sep = " "))
    
    print(p)

    dev.off()

  } #month loop

} #model loop
```

```{r}
pred.map.subset <- pred.map %>%
  filter(cal.month %in% c(2,6,12)) %>%
  mutate(monthLabel = month.abb[cal.month])
```

Plot.

```{r}
pdf(file = "figures/manuscript/Figure3.pdf", width = 6.69, height = 4.75, family = "sans")

ggplot() +
  geom_sf(data = pred.map.subset, aes(fill = mean.pred), color = NA) +
  scale_fill_viridis(option = "magma", direction = -1, discrete = F,
                     na.value = "gray70", 
                     guide = guide_colorbar(
                       title = "Probability",
                       direction = "vertical",
                       barheight = unit(35, units = "mm"),
                       barwidth = unit(2, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       title.hjust = 0.5,
                       label.hjust = 0.5,
                       title.theme = element_text(size = 8, angle = 0),
                       label.theme = element_text(size = 8, angle = 0))) +
  facet_wrap(~model + monthLabel) +
  geom_sf(data = nhp.split.map, fill = NA, color = "black")

dev.off()
```

Eventually the one.model will not have the split in it. I just can't figure it out yet.

Caption: Probability of yf spillover averaged over calendar month for Dec., Feb., and Jun. Result from single model in top row and dual process model in bottom row.

# Figure 4: Lattice Plot 

Figure showing results collapsed over space and time in a lattice. 

## Load Data
```{r}
# spatial data
braz.map <- st_read("../data_clean", "BRAZpolygons")
braz.map <- rename(braz.map, muni.no = muni_no)

#get brazil outline
braz.outline <- getData('GADM', country ='BRA', level = 0)
braz.outline <- st_as_sf(braz.outline)
braz.outline <- dplyr::select(braz.outline , id = OBJECTID, ID_0, ISO)

# prediction data
pred.one.model <- readRDS("../data_out/MS_results/OneModel/wholePredictions.rds")
pred.highNHP <- readRDS("../data_out/MS_results/HighModel/wholePredictions.rds")
pred.lowNHP <- readRDS("../data_out/MS_results/LowModel/wholePredictions.rds")

```


```{r download background countries}
#cshapes package?
```


## Calculate Values

### Over Space

I'm calculating the variance per municipality to get a measure of "flickering". The variance is calculated on the raw values.

```{r}
# calculate variance per municipality over whole time period
var.one.model <- as.data.frame(pred.one.model) %>%
  group_by(muni.no) %>%
  summarise(pred.var = var(prediction)) %>%
  mutate(model = "one.model")

var.highNHP <- as.data.frame(pred.highNHP) %>%
  group_by(muni.no) %>%
  summarise(pred.var = var(prediction)) %>%
  mutate(model = "highNHP")

var.lowNHP <- as.data.frame(pred.lowNHP) %>%
  group_by(muni.no) %>%
  summarise(pred.var = var(prediction)) %>%
  mutate(model = "lowNHP")

var.all.models <- rbind(var.one.model, var.highNHP, var.lowNHP) %>%
  left_join(braz.map, by = "muni.no")

rm(var.one.model, var.highNHP, var.lowNHP)

var.all.models$model <- factor(var.all.models$model, levels = c("one.model", "lowNHP", "highNHP"))
```


### Over Time

This looks at a time series, averaged over all municipalities by month. This is plotting the probabilities. Note that this kind of creates a problem because they are on such different scales. We can make the y axis of each plot free if we want to visualize the seasonality better. Or not plot probability.

```{r}
time.one.model <- as.data.frame(pred.one.model) %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  group_by(month.no) %>%
  summarise(pred.mean = mean(pred.scale, na.rm = T)) %>%
  mutate(model = "one.model")

time.lowNHP <- as.data.frame(pred.lowNHP) %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  group_by(month.no) %>%
  summarise(pred.mean = mean(pred.scale, na.rm = T)) %>%
  mutate(model = "lowNHP")

time.highNHP <- as.data.frame(pred.highNHP) %>%
  mutate(pred.scale = prediction * (sum(case)/n())) %>%
  group_by(month.no) %>%
  summarise(pred.mean = mean(pred.scale, na.rm = T)) %>%
  mutate(model = "highNHP")

time.all.models <- rbind(time.one.model, time.highNHP, time.lowNHP) 

#create cal.month variable (1 - 12)
time.all.models <- time.all.models %>%
  mutate(cal.month = month.no %% 12)

time.all.models$cal.month[time.all.models$cal.month==0] <- 12

#create year variable
time.all.models <- time.all.models %>%
  mutate(year = ((month.no-1) %/% 12) + 2001) %>%
  mutate(monthLabel = month(cal.month, label = T))

#order models
time.all.models$model <- factor(time.all.models$model, levels = c("one.model", "lowNHP", "highNHP"))

rm(time.one.model, time.highNHP, time.lowNHP)
```

## Plot

### Over Space

```{r map theme}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "left",
    panel.grid = element_blank(),
    plot.background = element_rect(fill = NA, color = NA), 
    panel.background = element_rect(fill = NA, color = NA), 
    legend.background = element_rect(fill = NA, color = NA),
    strip.background = element_blank(),
    strip.text = element_blank(),
    plot.margin = unit(c(0,5,0,5), unit = "pt"),
    ...
  )
}
```

## Add gray background to this

```{r facet}
top.row <- ggplot() +
    geom_sf(data = braz.outline, color = "gray25", size = 0.1) +
    geom_sf(data = var.all.models, aes(fill = pred.var), color = NA) +
    coord_sf(datum = NA)+
    scale_fill_viridis(option = "magma", direction = -1, discrete = F,
                     na.value = "gray70", 
                     guide = guide_colorbar(
                       title = "Variance",
                       direction = "vertical",
                       barheight = unit(35, units = "mm"),
                       barwidth = unit(2, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5,
                       title.theme = element_text(size = 8, angle = 0),
                       label.theme = element_text(size = 8, angle = 0))) +
    theme_map() +
  facet_wrap(~model, dir = "h") +
  panel_border()
```


### Over Time

We plot a line for each year, with a detrended loess line in a darker color.

```{r try a facet}
bottom.row <-  ggplot(data = time.all.models, aes(x = monthLabel, y = pred.mean)) +
    geom_line(aes(group = year), color = "gray70")+
    geom_smooth(aes(x = cal.month, y = pred.mean), se = F, color = "black") +
    theme_minimal() +
    ylab("Mean Probability") +
    xlab("") +
    scale_x_discrete(breaks = c("Jan","Mar","May","Jul","Sep","Nov")) +
    theme(
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      axis.text.x = element_text(size = 10, angle = 90, 
                                 vjust=0.2, hjust = 0),
      panel.background = element_blank(),
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      axis.line = element_line(),
      panel.grid = element_blank(),
      axis.line.y = element_line(),
      axis.ticks.length = unit(0.5, "lines"),
      axis.ticks = element_line()
    ) +
  facet_wrap(~model) +
  panel_border()
```

## Combine into one lattice plot

Use cowplot. Note sometimes you need to make sure any pdf devices are off by running `dev.off()` a whole bunch of times first.

```{r}
pdf(file = "figures/manuscript/Figure4.pdf", width = 6.69, height = 4.75, family = "sans")

ggdraw() +
  draw_plot(top.row, x = 0, y = 0.5, width = 1, height = 0.5) +
  draw_plot(bottom.row, x = 0.02, y = 0, width = 0.98, height = 0.5) +
  draw_plot_label(label = letters[1:6],
                  x = c(0.1,0.4,0.72,0.1,0.4,0.72),
                  y = c(1,1,1,0.55,0.55,0.55), 
                  size = 12)

dev.off()
```

**Caption:** Model variance through space (a,b,c) and time(d,e,f). Plots of variance municipality-level predictions using the single process model (a), dual process model with low reservoir richness (b), and dual process model with high reservoir richness (c). Mean probability across the entire study area of Brazil for the single process model (e), dual process model with low reservoir richness (e), and dual process model with high reservoir richness (f). Gray lines represent an individual year of data with overall mean in black.


# Supp. Figure X: Gif of maps

A seperate GIF for each model. Or maybe one GIF showing all three models at once, which would be more helpful but could be a huge file. 
