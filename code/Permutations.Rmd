---
title: "Permutations"
author: "Kaul"
date: "12/6/2017"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, warning = FALSE, cache=TRUE)
library(gplots)
library(ggplot2)
library(dplyr)
library(sf)
library(plotly)

```


#Meeting with John Dec 6th

## Variable Permutations Methods

Within the training dataset each variable was permuted 10 times. These permutated datasets were then used to make a logistic model bagged 100 times. The bagged model was used to predict on the entire (unbalanced) training dataset. The AUC for each permuted dataset of a given variable was then averaged. This mean AUC was subtracted from the base model AUC (delta AUC). The delta AUC was rescaled max(delta AUC) to yield variable importance. This whole process took roughly 4 hours using 20 cores of the high memory machine. 
 
```{r load data}
PermFullModel <- readRDS("../data_out/TempSplit/PermFullModel.rds")
```

## Variable Importance

The population size is the most importance variable. 
```{r RelImp, fig.width=15, fig.height=10}
#model
glm.formula <- as.formula("case~  
                                NDVI+NDVIScale+
                                popLog10+
                                RFsqrt+RFScale+
                                tempMean+tempScale+
                                fireDenSqrt+fireDenScale+
                                spRich+primProp") 

variables <- trimws(unlist(strsplit(as.character(glm.formula)[3], "+", fixed = T)), which = "both")
variablesName <- c("full model", variables, "all permutated")

#Plot relative Importance  
RelImp <- PermFullModel[[1]]
names(RelImp) <- variables
barplot(RelImp)

#rank relative importance
sort(RelImp)
```

## Absolute AUC

All variables were permuted simultaneously to get at the baseline AUC of the model approach. It is roughly 0.5 but has wide variability. 

```{r AUC, fig.width=15, fig.height=10}
AUC <- PermFullModel[[2]]
AUC$meanAUC <- as.numeric(as.character(AUC$meanAUC))#stupid format
AUC$sdAUC <- as.numeric(as.character(AUC$sdAUC))

AUC[order(AUC$meanAUC, decreasing = TRUE),]
library(gplots)
    plotCI(x=c(1:length(AUC$Model)),y=AUC$meanAUC, uiw=AUC$sdAUC, gap=0, xaxt="n", xlab="Permuted Variable", ylab="Mean AUC (10 permutations)")
    axis(1, at=c(1:length(AUC$Model)), labels=AUC$Model)

```

## Variable Key

- case :reporting of any YF cases (0,1)

- NDVI : NDVI for that month
- NDVIScale : NDVI rescaled to max value for that muni and calendar month
- popLog10 : population density 
- RFsqrt : mean hourly rainfall sqrt transformed
- RFScale : mean hourly rainfall rescaled to max value for that muni and calendar month
- tempMean : mean monthly air temperature 
- tempScale : mean monthly air temperature rescaled to max value for that muni and calendar month
- fireDenSqrt : number of fires oberserved in month divided by muniArea sqrt transformed
- firesDenScale : number of fires oberserved in month divided by muniArea rescaled to max value for that muni and calendar month. NA values converted to zero. 
- spRich : number of non-human primates by species with ranges based on IUCN {0-22}
- primProp : sum of each municipalities relative area that is both agricultural and falls within a primate genus range. {0,9} Missing for 2014

## Code to run permutations

```{r, eval=FALSE}
source("functions/baggingWperm.R")
#foundational bagging function
bagging

#To create permute data 
permutedata

#To determine variable importance
permOneVar

#To make predictions
BaggedModel
```

****

#Further exploring permutations 

## Permutation Methods 

The methods for the workflow have not changed with the exception of increasing the number of bags from 100 to 1000. This analysis explores different variable combinations. Permutation3, the *final* model was permuted a total of 100 times (instead of the standard 10). 


### Permutation 1: Popless
  Drop One model exploration showed that population was the main explanatory variable. However, the models with population permutated (100bags, 10 perm) did not have a large drop in AUC. For this reason, we should explore model permutations after dropping population. 
  
  
  
```{r Popless}
#drop one covar importance
glm.formula.popless <- as.formula("case~  NDVI+NDVIScale+ 
                          RFsqrt+RFScale+
                          tempMean+tempScale+
                          fireDenSqrt+fireDenScale+
                          spRich+primProp") 

PoplessVariables <- trimws(unlist(strsplit(as.character(glm.formula.popless)[3], "+", fixed = T)), which = "both")
#increased number of bagged models to 1000 from 100
#PermPoplessModel <- permOneVar(formula = glm.formula.popless,traindata = training.data, cores=20, no.iterations = 1000, perm = 10 ) 
```

The stdev around the AUC for the fully permutated model is reassuring. The model performance is slightly impacted by removing population. The order of relative importance for the environmental covariates hasn't changed.  
```{r Popless plots, fig.width=15, fig.height=10, echo=FALSE,warning = FALSE}

PermPoplessModel <- readRDS("../data_out/TempSplit/PermPoplessModel.rds")

PermPoplessAUC <- PermPoplessModel[[2]]
PermPoplessAUC[,2] <- round(as.numeric(as.character(PermPoplessAUC[,2])),digits=3)
PermPoplessAUC[,3] <- round(as.numeric(as.character(PermPoplessAUC[,3])),digits=3)

PermPoplessAUC[order(PermPoplessAUC$meanAUC),]

PermPoplessRelImp <- PermPoplessModel[[1]]
barplot(PermPoplessRelImp, names.arg = PoplessVariables, cex.axis = .75)

plotCI(x=c(1:length(PermPoplessAUC$Model)),y=PermPoplessAUC$meanAUC, uiw=PermPoplessAUC$sdAUC, gap=0, xaxt="n", xlab="Permuted Variable", ylab="Mean AUC (10 permutations; 1000 bags)")
axis(1, at=c(1:length(PermPoplessAUC$Model)), labels=PermPoplessAUC$Model)

```

### Permutation 2: Single flavor 

Is the second environmental covariate really adding anything to the model? The more important of the two flavors of each covariate (based on Permutation 1) were used to build a low variable model. All fire covariates were removed as well. 

```{r single flavor}
#permute one covar importance, single flavor (SF) of each covariate
glm.formula.SF <- as.formula("case~  NDVIScale+ 
                          RFsqrt+
                          tempMean+
                          spRich") 

SingleVariables <- trimws(unlist(strsplit(as.character(glm.formula.SF)[3], "+", fixed = T)), which = "both")

#PermSFModel <- permOneVar(formula = glm.formula.SF,traindata = training.data, cores=20, no.iterations = 1000, perm = 10 ) #increased number of bagged models to 1000 from 100
```

Again, the model performance isn't strongly impacted by removing variables. However, the all permutated model has a slighted elevated mean AUC and larger error.

```{r single flavor plots, fig.width=15, fig.height=10, echo=FALSE}
PermSFModel <- readRDS("../data_out/TempSplit/PermSFModel.rds")

PermSFAUC <- PermSFModel[[2]]
PermSFAUC[,2] <- round(as.numeric(as.character(PermSFAUC[,2])),digits=3)
PermSFAUC[,3] <- round(as.numeric(as.character(PermSFAUC[,3])),digits=3)

PermSFAUC[order(PermSFAUC$meanAUC),]

PermSFRelImp <- PermSFModel[[1]]
barplot(PermSFRelImp, names.arg = SingleVariables, cex.axis = .75)

plotCI(x=c(1:length(PermSFAUC$Model)),y=PermSFAUC$meanAUC, uiw=PermSFAUC$sdAUC, gap=0, xaxt="n", xlab="Permuted Variable", ylab="Mean AUC (10 permutations; 1000 bags)")
axis(1, at=c(1:length(PermSFAUC$Model)), labels=PermSFAUC$Model)

```

### Permutation 3: Single flavor with population

Before running this model, we felt like this *should* be the final model. That along with the variation of the all permutated model of Permuation 2 we increased the number of permutations was increased from 10 to 100. 

```{r single flavor plus pop}
#permute one covar importance, single flavor (SF) of each covariate
glm.formula.SFP <- as.formula("case~  popLog10+ 
                          NDVIScale+ 
                          RFsqrt+
                          tempMean+
                          spRich") 

SFPVariables <- trimws(unlist(strsplit(as.character(glm.formula.SFP)[3], "+", fixed = T)), which = "both")

#PermSFPModel <- permOneVar(formula = glm.formula.SFP,traindata = training.data, cores=20, no.iterations = 1000, perm = 100 ) #increased number of bagged models to 1000 from 100
```

This code took about 3.5 days to run. The model AUC looks good. The variability around the all permutated model is still high. I wonder if this is expected in models with fewer variables? 

```{r single flavor plue pop plots, fig.width=15, fig.height=10, echo=FALSE}
PermSFPModel <- readRDS("../data_out/TempSplit/PermSFPModel.rds")

PermSFPAUC <- PermSFPModel[[2]]
PermSFPAUC[,2] <- round(as.numeric(as.character(PermSFPAUC[,2])),digits=3)
PermSFPAUC[,3] <- round(as.numeric(as.character(PermSFPAUC[,3])),digits=3)

PermSFPAUC[order(PermSFPAUC$meanAUC),]

PermSFPRelImp <- PermSFPModel[[1]]
barplot(PermSFPRelImp, names.arg = SFPVariables, cex.axis = .75, ylab="Relative Importance")

```

## Exploring Predictions and Results

### Map of Predictions over time

Map of predictions and known cases by month (created via `mappingPredictions.Rmd`). This is only on the training data (hence the blank municipalities), and includes known true cases as green diamonds.

![Animation of predictions](figures/GIFplots/predictionsAll.gif)

### Ranking of Predictions

We want to explore how the predictions rank, noting where known positives fall out. This plot plots until the lowest ranked known positive. 
```{r}
predictions <- as.data.frame(readRDS("../data_out/Predictions/SFPPredPlot.rds"))

minTrue <- min(predictions$prediction[predictions$case == 1])
predRank <- predictions %>%
  #filter(prediction>minTrue) %>% #trim off predictions below the last true postive
  arrange(desc(prediction))

predRank$index <- seq.int(nrow(predRank))

ggplot(data = predRank[predRank$case == 0,], aes(y = prediction, x = index)) +
  geom_point(color = "gray80") +
  geom_point(data = predRank[predRank$case == 1,], aes(y = prediction, x = index), color = "maroon") +
  ylab("Prediction")+
  xlab("Rank order")+
  theme_bw() +
  ggtitle("Rank Order of ALL Training Data")

truePos <- predictions[predictions$case==1,]

bgPreds <- predictions[predictions$case==0,]
```

The lowest prediction for a known case is `r round(minTrue,3)`. `r nrow(predRank)` instances fall above this, out of a total of `r nrow(predictions)`. The mean value given to true positives is `r round(mean(truePos$prediction),3)` \pm `r round(sd(truePos$prediction),3)` *sd*, compared to `r round(mean(bgPreds$prediction),3)` \pm `r round(sd(bgPreds$prediction),3)` *sd* for the background points.

Histograms of the predictions are as follows:

```{r}
hist(truePos$prediction, main = "Predictions on True Positives")

hist(bgPreds$prediction, main = "Predictions on Background")
```

## Feedback from John Dec 15th

* Is the point process clumped? 
    +  Include a map with all the infected municipalities. The more occurances, the hotter or larger the point.
- Are there different processes influencing spillover/reporting in rural vs urban areas?
    +  Create 2 models using data split into develped/undeveloped. (Undeveloped includes State of Amazonas, Roraima, etc.)
    +  Compare rank order of variable importance between the two models. 
- Model discrimination (categorizing true positive) vs calibration (raw value of the model output)
    +  We should focus on discrimination (id. the most risky area, then the next, etc.) not calibration (this area is X%. this area is Y%, etc.).
    +  The model is not returning raw probabilities but something proportional to the intensity of events. The probability would be derived by multiplying the model output by the ratio of cases to background points. 
    +  The rank order of the model output has an interesting shape unlike other models (didn't ask follow up on that). Would be interesting to see all the points plotted (done). 

****

# Comparing variable importance of one model vs two models

## Methods 

John suggested we explore the possibility of two different point processes for yellow fever spillover in Brazil. We split the country into two region- the northwest with high primate diversity ($\geq 6$ of 22) and the remaining portion with low primate diversity. A threshold of 6 species produced the most contiguous region of high primate diversity. The previous iterations of this work was using a temporially balanced split for training and testing data. This split was redone to create a balanced split in 3 dimensions (x space, y space and time). The newly space and time balanced data for the whole country (used for the one model approach) was then split into high and low non-human primate diversity regions (used for the two model approach). The 2014 data was removed due to missing primProp values (landuse data not available).

Models consisted of 500 bags and 10 permutations unless otherwise stated. This bag/permutation scheme was a based on computational time and memory. 


```{r space and time map, echo=FALSE}

YF <- readRDS("../data_clean/YFcases/YFlong.rds")
brazil <- st_read("../data_clean", "BRAZpolygons")

# calculate total cases per muni
totCase <- YF %>%
  group_by(muni.no) %>%
  filter(!is.na(case)) %>%
  summarise(totalCases=sum(case, na.rm=T), totalMonths = n_distinct(month.no))
  

# add to shapefile
brazilYF <- merge(brazil, totCase, by.y="muni.no", by.x = "muni_no", all.x = T)

theme_map <- function(...) {
  theme_minimal() +
  theme(
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # panel.grid.minor = element_line(color = "#ebebe5", size = 0.2),
    # panel.grid.major = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = NA, color = NA), 
    panel.background = element_rect(fill = "gray80", color = NA), 
    legend.background = element_rect(fill = NA, color = NA),
    panel.border = element_blank(),
    ...
  )
}

#load data
indexSplit <- readRDS("../data_clean/environmental/twoModelSplit.rds")

brazilYF <- merge(brazilYF, indexSplit, by.x = "muni_no", by.y = "muni.no")

#r calculate centroids for circles
brazCnt <- data.frame(st_coordinates(st_centroid(brazilYF)), muni.no = brazilYF$muni_no, totalMonths = brazilYF$totalMonths)

#map
ggplot() +
  # municipality polygons colored by NHP
  geom_sf(data = brazilYF, aes(fill = above5split), color = NA) +
  scale_fill_manual(values = c("honeydew1", "navajowhite1"), labels = c("High NHP", "Low NHP"), name = "Which primate model?")+
  geom_point(data = brazCnt, aes(size = totalMonths, x= X, y = Y), alpha = 0.5, fill = "dodgerblue", color = "black",pch=21) +
  scale_size_area(name = "Number of months with cases")+
  theme_map()

```



## Rank Order of Variable Importance

Models were built using all of the covariates (`full.formula`) and just environmental covariates (`popless.formula`). If there is a single point process, we'd expect the rank order of variable importance to be the same in the full, low NHP, and high NHP model. If there are two seperate point processes we'd expect the full model and the low NHP model to be similar, while the high NHP to be different. This is because the much larger low NHP process is overwhelming the high NHP point process in the full model. 

```{r formula, echo=TRUE}

full.formula <- as.formula("case~  NDVI+NDVIScale+
                          popLog10+
                          RF+RFsqrt+RFScale+
                          tempMean+tempScale+
                          fireDenSqrt+fireDenScale+
                          spRich+primProp") 


 popless.formula <- as.formula("case~  NDVI+NDVIScale+ 
                          RFsqrt+RFScale+
                          tempMean+tempScale+
                          fireDenSqrt+fireDenScale+
                          spRich+primProp") 
```

### Model with all variables

```{r full models, echo=FALSE}

#Return Quick Rank Importance
RankImp=function(x){
  #pull out Relative Importance
  RI <- x[[1]]
  #order and add rank
  RI <- RI %>%
  dplyr::arrange(desc(varImp)) %>%
  dplyr::mutate(varRank=1:dim(RI)[1])
  
  return(RI)
}

#functions
#Return Quick Rank Importance
RankAUC=function(x){
PermSFAUC <- x[[2]]
PermSFAUC[,2] <- round(as.numeric(as.character(PermSFAUC[,2])),digits=3)
PermSFAUC[,3] <- round(as.numeric(as.character(PermSFAUC[,3])),digits=3)
#PermSFAUC <- PermSFAUC[order(PermSFAUC$meanAUC),]
#PermSFAUC$Rank <- c(0:(dim(PermSFAUC)[1]-1))
return(PermSFAUC)
}


FullModel <- readRDS("../data_out/SpaceAndTimeSplit/Trim2014/Perm10FullModel500.rds")
HFullModel <- readRDS("../data_out/TwoModelSoln/Trim2014/HPermFullModel.rds") 
LFullModel <- readRDS("../data_out/TwoModelSoln/Trim2014/LPermFullModel.rds")


Full <- RankImp(FullModel)
HFull <- RankImp(HFullModel)
LFull <- RankImp(LFullModel)

RankFull <- rbind(Full,LFull, HFull)
RankFull$Model <- factor(c(rep("Full", dim(Full)[1]),
                           rep("Low NHP", dim(LFull)[1]),
                           rep("High NHP", dim(HFull)[1])),
                         levels=c("Full", "Low NHP", "High NHP"))
#order the variable levels
RankFull <- within(RankFull,
                    Variable <- factor(Variable, 
                      levels = c( "spRich", "popLog10", "RFsqrt","NDVIScale","tempMean","RF","primProp", "fireDenScale", "fireDenSqrt","tempScale","NDVI")))

RankFull$varImp <- as.numeric(as.character(RankFull$varImp))

#Relative Imp Plots

b <- ggplot(RankFull, aes(Variable, varImp)) + 
    geom_bar(stat="identity") +
    facet_grid(Model~.) +
    ylab("Relative Importance") + xlab("variable") +
    theme(axis.text.x=element_text(angle=45, hjust=1))

#cord plot business
y_levels <- levels(RankFull$Variable)

p <- ggplot(RankFull, aes(x = Model, y = varRank, group = Variable)) +   # group = id is important!
  geom_path(aes(color = Variable),lineend = 'round', linejoin = 'round') +
  scale_y_discrete(limits = levels(RankFull$Variable)) +
  ylab("Rank Importance (1 is most important)") +
  theme(legend.position = "none")
```

The absolute AUC values for the full model, low NHP, and high NHP are `r RankAUC(FullModel)[1,2]`, `r RankAUC(LFullModel)[1,2]`,`r RankAUC(HFullModel)[1,2]`,respectively. If there is no change in the rank order the coordinate plot should be relatively flat. This is the case between the full and low and NHP models 


```{r  plot, echo=FALSE}

ggplotly(b)


ggplotly(p)

```


```{r full model true positives, echo=FALSE}
#quick sort and index function
IdSort=function(x, mod="NA"){
  if(!is.data.frame(x)){x <- as.data.frame(x)}
  xSort <- x %>%
           arrange(desc(prediction)) %>%
           mutate(Model=mod, index=c(1:dim(x)[1]))
  return(xSort)
}


load("../data_out/Predictions/TwoModel/Trim2014/fullPredictions.RData")
hPFull<- IdSort(hPredFull,mod="High NHP")
lPFull<- IdSort(lPredFull,mod="Low NHP")
#build dataset for easy plotting
fullPred <- rbind(hPFull, lPFull)
ggplot(data = fullPred, aes(y = prediction, x = index)) +
  geom_point(color = "gray80") +
  geom_point(data = fullPred[fullPred$case == 1,], aes(y = prediction, x = index), color = "maroon") +
  ylab("Prediction")+
  xlab("Rank order")+
  facet_wrap(~Model, scales="free_x")+
  ggtitle("Rank Order of ALL Training Data")

```

### Popless Model


```{r popless model , echo=FALSE}

PoplessModel <- readRDS("../data_out/SpaceAndTimeSplit/Trim2014/Perm10PoplessModel500.rds")
HPoplessModel <- readRDS("../data_out/TwoModelSoln/HPermPoplessModel.rds")
LPoplessModel <- readRDS("../data_out/TwoModelSoln/LPermPoplessModel.rds")

Popless <- RankImp(PoplessModel)
HPopless <- RankImp(HPoplessModel)
LPopless <- RankImp(LPoplessModel)



RankPop <- rbind(Popless,LPopless, HPopless)
RankPop$Model <- factor(c(rep("Full", dim(Popless)[1]),
                           rep("Low NHP", dim(LPopless)[1]),
                           rep("High NHP", dim(HPopless)[1])),
                         levels=c("Full", "Low NHP", "High NHP"))
#order the variable levels
RankPop <- within(RankPop,
                    Variable <- factor(Variable, 
                      levels = c( "spRich","NDVIScale","tempMean","RFsqrt","primProp","tempScale","NDVI", "fireDenScale", "fireDenSqrt")))

RankPop$varImp <- as.numeric(as.character(RankPop$varImp))

#Relative Imp Plots

b <- ggplot(RankPop, aes(Variable, varImp)) + 
    geom_bar(stat="identity") +
    facet_grid(Model~.) +
    ylab("Relative Importance") + xlab("variable") +
    theme(axis.text.x=element_text(angle=45, hjust=1))

p<- ggplot(RankPop, aes(x = Model, y = varRank, group = Variable)) +   # group = id is important!
  geom_path(aes(color = Variable),lineend = 'round', linejoin = 'round') +
  scale_y_discrete(limits = levels(RankPop$Variable)) +
  ylab("Rank Importance (1 is most important)") +
  theme(legend.position = "none")


```


The absolute AUC values for the full model, low NHP, and high NHP are `r RankAUC(PoplessModel)[1,2]`, `r RankAUC(LPoplessModel)[1,2]`,`r RankAUC(HPoplessModel)[1,2]`,respectively.


```{r popless  plot, echo=FALSE}

ggplotly(b)


ggplotly(p)

```


```{r popless model true positives, echo=FALSE}


load("../data_out/Predictions/TwoModel/Trim2014/poplessPredictions.RData")
hPFull<- IdSort(hPredPopless,mod="High NHP")
lPFull<- IdSort(lPredPopless,mod="Low NHP")
#build dataset for easy plotting
fullPred <- rbind(hPFull, lPFull)
ggplot(data = fullPred, aes(y = prediction, x = index)) +
  geom_point(color = "gray80") +
  geom_point(data = fullPred[fullPred$case == 1,], aes(y = prediction, x = index), color = "maroon") +
  ylab("Prediction")+
  xlab("Rank order")+
  facet_wrap(~Model, scales="free_x")+
  ggtitle("Rank Order of ALL Training Data")

```

*****

<!-- ## Effect of Spatially Balanced Split on Single Point Process Model -->

<!-- https://datascience.blog.wzb.eu/2016/09/27/parallel-coordinate-plots-for-discrete-and-categorical-data-in-r-a-comparison/ -->

<!-- ```{r compare balance splits, eval=FALSE} -->
<!-- #load all the data  -->
<!-- STPermFullModel <- readRDS("../data_out/SpaceAndTimeSplit/PermFullModel500.rds") -->
<!-- STPermPoplessModel <- readRDS("../data_out/SpaceAndTimeSplit/PermPoplessModel500.rds") -->
<!-- STFull<- RankImp(STPermFullModel) -->
<!-- STPopless<- RankImp(STPermPoplessModel) -->



<!-- STPermSFModel <- readRDS("../data_out/SpaceAndTimeSplit/PermSFModel500.rds") -->

<!-- #Temperal split -->
<!-- PermFullModel <- readRDS("../data_out/TempSplit/PermFullModel.rds") -->
<!-- PermPoplessModel <- readRDS("../data_out/TempSplit/PermPoplessModel.rds") -->

<!-- STFull<- RankImp(STPermFullModel) -->
<!-- Full <- RankImp(PermFullModel) -->
<!-- STPopless<- RankImp(STPermPoplessModel) -->
<!-- STSF <- RankImp(STPermSFModel) -->


<!-- #This is the important chunck of the code  -->
<!-- VariRank <-  STFull %>% -->
<!--               select(c(Model, STFull=Rank)) %>% -->
<!--               dplyr::left_join(Full %>% select(c(Model, TFull=Rank)), by="Model") -->

<!-- ``` -->



